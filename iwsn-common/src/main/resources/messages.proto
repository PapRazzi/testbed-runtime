///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Copyright (c) 2012, Institute of Telematics, University of Luebeck                                                //
// All rights reserved.                                                                                              //
//                                                                                                                   //
// Redistribution and use in source and binary forms, with or without modification, are permitted provided that the  //
// following conditions are met:                                                                                     //
//                                                                                                                   //
// - Redistributions of source code must retain the above copyright notice, this list of conditions and the following//
//   disclaimer.                                                                                                     //
// - Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the       //
//   following disclaimer in the documentation and/or other materials provided with the distribution.                //
// - Neither the name of the University of Luebeck nor the names of its contributors may be used to endorse or       //
//   promote products derived from this software without specific prior written permission.                          //
//                                                                                                                   //
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,//
// INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE     //
// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,        //
// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE//
// GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF   //
// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  //
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.                               //
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

package de.uniluebeck.itm.tr.iwsn.messages;

option java_outer_classname = "Messages";
option java_multiple_files = true;

/////////////////////// REQUESTS /////////////////////// 

message RequestResponseHeader {

	optional string reservationId = 1; // an (optional) reservation ID, if request is associated with a reservation
	required int64  requestId     = 2; // an ID to match requests and responses, should be unique for given time window
	required uint64 timestamp     = 3; // a timestamp in Unix format
	repeated string nodeUrns      = 4; // node URN(s) to which this request goes to / this response comes from

	// routing directions, not serialized if not set or equal to default value
	optional bool   downstream    = 5 [default = true];  // true if message should be forwarded towards nodes
	optional bool   upstream      = 6 [default = false]; // true if message should be forwarded towards user
}

message Link {
	required string sourceNodeUrn = 1;
	required string targetNodeUrn = 2;
}

message AreNodesAliveRequest {
	required RequestResponseHeader header     = 1;
	optional MessageType           type       = 2 [default = REQUEST_ARE_NODES_ALIVE];
}

message AreNodesConnectedRequest {
	required RequestResponseHeader header     = 1;
	optional MessageType           type       = 2 [default = REQUEST_ARE_NODES_CONNECTED];
}

message DisableNodesRequest {
	required RequestResponseHeader header   = 1;
	optional MessageType           type     = 2 [default = REQUEST_DISABLE_NODES];
}

message DisableVirtualLinksRequest {
	required RequestResponseHeader header = 1;
	optional MessageType           type   = 2 [default = REQUEST_DISABLE_VIRTUAL_LINKS];
	repeated Link                  links  = 3;
}

message DisablePhysicalLinksRequest {
	required RequestResponseHeader header = 1;
	optional MessageType           type   = 2 [default = REQUEST_DISABLE_PHYSICAL_LINKS];
	repeated Link                  links  = 3;
}

message EnableNodesRequest {
	required RequestResponseHeader header = 1;
	optional MessageType           type   = 2 [default = REQUEST_ENABLE_NODES];
}

message EnablePhysicalLinksRequest {
	required RequestResponseHeader header = 1;
	optional MessageType           type   = 2 [default = REQUEST_ENABLE_PHYSICAL_LINKS];
	repeated Link                  links  = 3;
}

message EnableVirtualLinksRequest {
	required RequestResponseHeader header = 1;
	optional MessageType           type   = 2 [default = REQUEST_ENABLE_VIRTUAL_LINKS];
	repeated Link                  links  = 3;
}

message FlashImagesRequest {
	required RequestResponseHeader header   = 1;
	optional MessageType           type     = 2 [default = REQUEST_FLASH_IMAGES];
	required bytes                 image    = 3;
}

message GetChannelPipelinesRequest {
	required RequestResponseHeader header   = 1;
	optional MessageType           type     = 2 [default = REQUEST_GET_CHANNEL_PIPELINES];
}

message ResetNodesRequest {
	required RequestResponseHeader header   = 1;
	optional MessageType           type     = 2 [default = REQUEST_RESET_NODES];
}

message SendDownstreamMessagesRequest {
	required RequestResponseHeader header       = 1;
	optional MessageType           type         = 2 [default = REQUEST_SEND_DOWNSTREAM_MESSAGES];
	required bytes                 messageBytes = 3;
}

message ChannelHandlerConfiguration {
	message KeyValuePair {
		required string key   = 1;
		required string value = 2;
	}
	required string       name          = 1;
	repeated KeyValuePair configuration = 2;
}

message SetChannelPipelinesRequest {
	required RequestResponseHeader       header                       = 1;
	optional MessageType                 type                         = 2 [default = REQUEST_SET_CHANNEL_PIPELINES];
	repeated ChannelHandlerConfiguration channelHandlerConfigurations = 3;
}

message Progress {
	required RequestResponseHeader header            = 1;
	optional MessageType           type              = 2 [default = PROGRESS];
	required MessageType           requestType       = 3;
	required uint32                progressInPercent = 4;
}

message Response {
	required RequestResponseHeader header        = 1;
	optional MessageType           type          = 2 [default = RESPONSE];
	required MessageType           requestType   = 3;
	optional bytes                 response      = 4;
	optional int32                 statusCode    = 5;
	optional string                errorMessage  = 6;
}

message GetChannelPipelinesResponse {
	message GetChannelPipelineResponse {
		required string                      nodeUrn               = 1;
		repeated ChannelHandlerConfiguration handlerConfigurations = 2;
	}
	required RequestResponseHeader      header        = 1;
	optional MessageType                type          = 2 [default = GET_CHANNELPIPELINES_RESPONSE];
	repeated GetChannelPipelineResponse pipelines     = 3;
}

/////////////////////// EVENTS /////////////////////// 

message UpstreamMessageEvent {
	required EventHeader header       = 1;
	optional MessageType type         = 2 [default = EVENT_UPSTREAM_MESSAGE];
	required bytes       messageBytes = 3;
}

message DevicesAttachedEvent {
	required EventHeader header   = 1;
	optional MessageType type     = 2 [default = EVENT_DEVICES_ATTACHED];
}

message DevicesDetachedEvent {
	required EventHeader header   = 1;
	optional MessageType type     = 2 [default = EVENT_DEVICES_DETACHED];
}

message GatewayConnectedEvent {
	required EventHeader header   = 1;
	optional MessageType type     = 2 [default = EVENT_GATEWAY_CONNECTED];
	required string      hostname = 3;
}

message GatewayDisconnectedEvent {
	required EventHeader header   = 1;
	optional MessageType type     = 2 [default = EVENT_GATEWAY_DISCONNECTED];
	required string      hostname = 3;
}

message NotificationEvent {
	required EventHeader header  = 1;
	optional MessageType type    = 2 [default = EVENT_NOTIFICATION];
	required string      message = 3;
}

message ReservationStartedEvent {
	required EventHeader header        = 1;
	optional MessageType type          = 2 [default = EVENT_RESERVATION_STARTED];
	required string      serializedKey = 3;
}

message ReservationEndedEvent {
	required EventHeader header        = 1;
	optional MessageType type          = 2 [default = EVENT_RESERVATION_ENDED];
	required string      serializedKey = 3;
}

message ReservationMadeEvent {
	required EventHeader header        = 1;
	optional MessageType type          = 2 [default = EVENT_RESERVATION_MADE];
	required string      serializedKey = 3;
}

message ReservationCancelledEvent {
	required EventHeader header        = 1;
	optional MessageType type          = 2 [default = EVENT_RESERVATION_CANCELLED];
	required string      serializedKey = 3;
}

message ReservationClosedEvent {
	required EventHeader header        = 1;
	optional MessageType type          = 2 [default = EVENT_RESERVATION_CLOSED];
	required string      serializedKey = 3;
}

message ReservationFinalizedEvent {
	required EventHeader header        = 1;
	optional MessageType type          = 2 [default = EVENT_RESERVATION_FINALIZED];
	required string      serializedKey = 3;
}

message ReservationOpenedEvent {
	required EventHeader header        = 1;
	optional MessageType type          = 2 [default = EVENT_RESERVATION_OPENED];
	required string      serializedKey = 3;
}

message DeviceConfigCreatedEvent {
	required EventHeader header  = 1;
	optional MessageType type    = 2 [default = EVENT_DEVICE_CONFIG_CREATED];
}

message DeviceConfigUpdatedEvent {
	required EventHeader header  = 1;
	optional MessageType type    = 2 [default = EVENT_DEVICE_CONFIG_UPDATED];
}

message DeviceConfigDeletedEvent {
	required EventHeader header  = 1;
	optional MessageType type    = 2 [default = EVENT_DEVICE_CONFIG_DELETED];
}

message EventHeader {

	required int64  eventId   = 1; // an ID to identify events, should be unique for given time window
	required uint64 timestamp = 2; // a timestamp in Unix format
	repeated string nodeUrns  = 3; // zero or more node URNs (if this event originated from / is about node(s))

	// routing directions, not serialized if not set or equal to default value
	optional bool   downstream    = 5 [default = false]; // true if message should be forwarded towards nodes
	optional bool   upstream      = 6 [default = true];  // true if message should be forwarded towards user
}

message EventAck {
	required EventHeader header = 1;
	optional MessageType type   = 2 [default = EVENT_ACK];
}

/////////////////////// MESSAGE ENVELOPE /////////////////////// 

enum MessageType {

	KEEP_ALIVE                       = 01;
	KEEP_ALIVE_ACK                   = 02;

	REQUEST_ARE_NODES_ALIVE          = 11;
	REQUEST_ARE_NODES_CONNECTED      = 12;
	REQUEST_DISABLE_NODES            = 13;
	REQUEST_DISABLE_VIRTUAL_LINKS    = 14;
	REQUEST_DISABLE_PHYSICAL_LINKS   = 15;
	REQUEST_ENABLE_NODES             = 16;
	REQUEST_ENABLE_PHYSICAL_LINKS    = 17;
	REQUEST_ENABLE_VIRTUAL_LINKS     = 18;
	REQUEST_FLASH_IMAGES             = 19;
	REQUEST_GET_CHANNEL_PIPELINES    = 20;
	REQUEST_RESET_NODES              = 21;
	REQUEST_SEND_DOWNSTREAM_MESSAGES = 22;
	REQUEST_SET_CHANNEL_PIPELINES    = 23;

	PROGRESS                         = 30;
	RESPONSE                         = 31;
	GET_CHANNELPIPELINES_RESPONSE    = 32;

	EVENT_UPSTREAM_MESSAGE           = 40;

	EVENT_DEVICES_ATTACHED           = 50;
	EVENT_DEVICES_DETACHED           = 51;
	EVENT_GATEWAY_CONNECTED          = 52;
	EVENT_GATEWAY_DISCONNECTED       = 53;

	EVENT_NOTIFICATION               = 60;

	EVENT_RESERVATION_STARTED        = 70;
	EVENT_RESERVATION_ENDED          = 71;
	EVENT_RESERVATION_MADE           = 72;
	EVENT_RESERVATION_CANCELLED      = 73;
	EVENT_RESERVATION_OPENED         = 74;
	EVENT_RESERVATION_CLOSED         = 75;
	EVENT_RESERVATION_FINALIZED      = 76;

	EVENT_DEVICE_CONFIG_CREATED      = 80;
	EVENT_DEVICE_CONFIG_UPDATED      = 81;
	EVENT_DEVICE_CONFIG_DELETED      = 82;

	EVENT_ACK                        = 90;
}

message Message {

	required MessageType                   type                          = 1;

	// REQUESTS
	optional AreNodesAliveRequest          areNodesAliveRequest          = 111;
	optional AreNodesConnectedRequest      areNodesConnectedRequest      = 112;
	optional DisableNodesRequest           disableNodesRequest           = 113;
	optional DisableVirtualLinksRequest    disableVirtualLinksRequest    = 114;
	optional DisablePhysicalLinksRequest   disablePhysicalLinksRequest   = 115;
	optional EnableNodesRequest            enableNodesRequest            = 116;
	optional EnablePhysicalLinksRequest    enablePhysicalLinksRequest    = 117;
	optional EnableVirtualLinksRequest     enableVirtualLinksRequest     = 118;
	optional FlashImagesRequest            flashImagesRequest            = 119;
	optional GetChannelPipelinesRequest    getChannelPipelinesRequest    = 120;
	optional ResetNodesRequest             resetNodesRequest             = 121;
	optional SendDownstreamMessagesRequest sendDownstreamMessagesRequest = 122;
	optional SetChannelPipelinesRequest    setChannelPipelinesRequest    = 123;

	// RESPONSES
	optional Progress                      progress                      = 130;
	optional Response                      response                      = 131;
	optional GetChannelPipelinesResponse   getChannelPipelinesResponse   = 132;

	// EVENTS
	optional UpstreamMessageEvent          upstreamMessageEvent          = 140;

	optional DevicesAttachedEvent          devicesAttachedEvent          = 150;
	optional DevicesDetachedEvent          devicesDetachedEvent          = 151;
	optional GatewayConnectedEvent         gatewayConnectedEvent         = 152;
	optional GatewayDisconnectedEvent      gatewayDisconnectedEvent      = 153;

	optional NotificationEvent             notificationEvent             = 160;

	optional ReservationStartedEvent       reservationStartedEvent       = 170;
	optional ReservationEndedEvent         reservationEndedEvent         = 171;
	optional ReservationMadeEvent          reservationMadeEvent          = 172;
	optional ReservationCancelledEvent     reservationCancelledEvent     = 173;
	optional ReservationOpenedEvent        reservationOpenedEvent        = 174;
	optional ReservationClosedEvent        reservationClosedEvent        = 175;
	optional ReservationFinalizedEvent     reservationFinalizedEvent     = 176;

	optional DeviceConfigCreatedEvent      deviceConfigCreatedEvent      = 180;
	optional DeviceConfigUpdatedEvent      deviceConfigUpdatedEvent      = 181;
	optional DeviceConfigDeletedEvent      deviceConfigDeletedEvent      = 182;

	// EVENTS ACK
	optional EventAck                      eventAck                      = 190;
}
